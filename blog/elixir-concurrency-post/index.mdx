---
title: "LEARN CONCURRENCY IN ELIXIR WITH ME"
date: "2024-04-20"
slug: "concurrency-basics"
imagesDir: ./my-first-post/
hero_image: "./elixir.jpeg"
hero_image_alt: "Elixir logo"
hero_image_credit_text: "elixir-lang.org"
hero_image_credit_link: "https://raw.githubusercontent.com/rowah/APIs/main/imgs/concurrency.jpeg"
---

_I div into Elixir and found out how fun and easy to understand the language is. I want to learn its framework Phoenix by building a full stack travel blog application. I use this project to learn Phoenix contexts and authentication. Lets go!_

<br />
<p align="center">\* * * *</p>
<br />
Here is what we are going to do in the first part of this project:

<ol>
  <li>1. Set up a new Phoenix project</li>
  <li>2. Generate an Accounts context</li>
  <li>3. Generate an Blog context with a Post model</li>
  <li>4. Generate a Comment model inside the Blog context</li>
  <li>5. Create a comments controller</li>
  <li>6. Create a comments form, load and display comments</li>
</ol>

What is concurrency? The concurrency model relies on Actors, which are contained processes that communicates with other processes through message passing.
Processes? Are simple and its common to have many concurrent processes in an Elixir application. Are created through the spawn function which takes either an anonymous or a named function. A newly created process returns a PID (Process Identifier), that we can use to uniquely identify it within our Elixir application.

Here is a module with a function we would like to run;

<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
defmodule Example do
  def add(a, b) do
    IO.puts(a + b)
  end
end

iex> Example.add(2, 3)
5
:ok

````
</div>

To evaluate the function asynchronously we use spawn/3;

<div
style={{
  backgroundColor: "grey",
  paddingTop: "30px",
  paddingLeft: "10px",
  margin: "20px",
}}
>
```elixir
iex> spawn(Example, :add, [2, 3])
5
#PID<0.80.0>

````

</div>
How processes communicate? Processes communicate through passing messages, which has two components; send/2 (all messages to be sent to PIDs) and receive (all processes to listen and to match messages being sent from other processes).
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
defmodule Example do
    def listen do
        receive do
        {:ok, "hello"} -> IO.puts("World")
        end

        listen()

    end

end

iex> pid = spawn(Example, :listen, [])
#PID<0.108.0>

iex> send pid, {:ok, "hello"}
World
{:ok, "hello"}

iex> send pid, :ok
:ok

````
</div>
It’s important to note that the listen/0 function is recursive which allows a process to handle multiple messages. If this was not the case, the process would exit after handling the first message.
How are processes linked? Spawn has a problem of knowing when a process crashes, and so we need to link processes using spawn_link. Two linked processes can receive exit notifications from one another.


<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
  ```elixir
  defmodule Example do
  def explode, do: exit(:kaboom)
end

iex> spawn(Example, :explode, [])
#PID<0.66.0>

iex> spawn_link(Example, :explode, [])
** (EXIT from #PID<0.57.0>) evaluator process exited
with reason: :kaboom

````

</div>
What if we do not want a linked process to crash the current one? To achieve this, we need to trap the exits using Process.flag/2 which uses erlang’s process_flag/2 for the trap_exit flag. Trap_exit gets set to true when trapping exits, and exit signals will be received as a tuple message; :EXIT, from_pid, reason.

<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
  ```elixir
 defmodule Example do
  def explode, do: exit(:kaboom)

def run do
Process.flag(:trap_exit, true)
spawn_link(Example, :explode, [])

        receive do
        {:EXIT, _from_pid, reason} ->
        IO.puts("Exit reason: #{reason}")
        end

    end

end

iex> Example.run
Exit reason: kaboom
:ok

````

</div>

How do we monitor processes? Sometimes we may not want to link two processes but just want to be kept informed. For this we use spawn_monitor to.
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
  ```elixir
defmodule Example do
  def explode, do: exit(:kaboom)

  def run do
        spawn_monitor(Example, :explode, [])

        receive do
        {:DOWN, _ref, :process, _from_pid, reason} ->
        IO.puts("Exit reason: #{reason}")
        end
    end
end

iex> Example.run
Exit reason: kaboom
:ok


````

</div>
Agents, what are they? They are an abstraction around background processes maintaining state and can be accessed from other processes within our application and code. The state of our Agent is set to our function’s return value;
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
  ```elixir
{:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
{:ok, #PID<0.65.0>}

iex> Agent.update(agent, fn (state) -> state ++ [4, 5] end)
:ok

iex> Agent.get(agent, &(&1))
[1, 2, 3, 4, 5]

````

</div>
Named agents can be referred to by the names instead of its PID.
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
  ```elixir
Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
{:ok, #PID<0.74.0>}

iex> Agent.get(Numbers, &(&1))
[1, 2, 3]

````

</div>
And tasks? Provide a way to execute a function in the background and retrieve its returned value later. These can be useful when we handle expensive operations without blocking the application execution.
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
  ```elixir
defmodule Example do
  def double(x) do
    :timer.sleep(2000)
    x * 2
  end
end

iex> task = Task.async(Example, :double, [2000])
%Task{
owner: #PID<0.105.0>,
pid: #PID<0.114.0>,
ref: #Reference<0.2418076177.4129030147.64217>
}

# Do some work

iex> Task.await(task)
4000

```

</div>
```

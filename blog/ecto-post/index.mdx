---
title: "Learn Ecto with Me"
date: "2024-04-20"
slug: "ecto"
imagesDir: ./my-first-post/
hero_image: "./ectoo.png"
hero_image_alt: "Elixir logo"
hero_image_credit_text: "elixir-lang.org"
hero_image_credit_link: "https://github.com/rowah/APIs/blob/main/imgs/ectoo.png?raw=true"
---

_I dived into back-end development with Elixir and Phoenix and this is where I met ECTO. I am mastering this new skill and wanted to write an article about what I have learned this far._

<br />
<p align="center">\* * * *</p>
<br />
This article talks about Ecto, a Database wrapper and query generator for that helps
Elixir engineers to work with any type of database. After going through it, you will
understand;

<ol>
  <li>1. What Ecto is.</li>
  <li>What the main parts of Ecto are.</li>
  <li>2. What Ecto.Repo does.</li>
  <li>3. How to use migrations</li>
  <li>4. The importance of schemas.</li>
  <li>5. What changeset are and their role.</li>
</ol>

A DB wrapper and a query language. It provides a DB wrapper and integrated query language. Through Ecto, we can create migrations, define schemas, insert and update records, and query them.
Ecto supports different DBs through the use of adapters which include PostgreSQL, MySQL, SQLite.

Main parts of Ecto? The Repository (provides an interface to the DB including the connection), Migrations (a way to create, modify, and destroy database tables and indexes), Schemas (specialized structs that represent database table entries).

To start, we create an application with a supervision tree.

<div
  style={{
    backgroundColor: "grey",
    height: "100px",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
  mix new family --sup

cd family

</div>

We then need to add ecto and postgrex package deps to the mix.exs file and then use mix deps.get to fetch the dependencies;

<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
defp deps do
    [
      {:ecto_sql, "~> 3.2"},
      {:postgrex, "~> 0.15"}
    ]
  end

````

</div>

<br />

How to create a repository? We use a mix command;

<br />

<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
mix ecto.gen.repo -r Family.Repo

</div>

Generates the required configuration in config/config.exs to connect to a database including the adapter to use and a module Family.Repo inside the lib/family/repo.ex . Inside the config.exs file should look like this;

<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
config :family, Family.Repo,
  database: "family_repo",
  username: "postgres",
  password: "postgres",
  hostname: "localhost"

```
</div>

This configures how Ecto connects to the database. Note that you may need to configure your DB to have matching credentials. Inside the repo.ex file you should see;

<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
defmodule Family.Repo do
  use Ecto.Repo,
    otp_app: :family,
    adapter: Ecto.Adapters.Postgres
end

```
</div>

The Family.Repo is what we’ll be using to query our database.
We then set up the Family.Repo as a supervisor within our application’ supervision tree in lib/family/application.ex. to start the Ecto process when our application starts.

We then need to add the following line to our config/config.exs file to allow our app to run mix Ecto commands from the cpmmandline.


<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
config :family, ecto_repos: [Family.Repo]

</div>
Once we are done with the configurations, we can then create our database by running;
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
mix ecto.create

</div>

Migrations? Ecto provides migrations which enables us to create and modify tables inside the postgres database. Inside each migration, we have a set of actions to be performed on our database, like which tables to create and/or update.
Using the mix ecto.gen.migration task, let’s create a migration for members table which we need in the app.


<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
mix ecto.gen.migration create_members
</div>
The task creates a new file in the priv/repo/migrations folder with timestamps in the file name. It looks something like;
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
defmodule Family.Repo.Migrations.CreateMembers do
  use Ecto.Migration

  def change do

  end
end

```
</div>

We need to modify the change/0 function to create a new table for members with first name, last name, and age

<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
defmodule Family.Repo.Migrations.CreatePeople do
  use Ecto.Migration

  def change do
    create table(:members) do
      add :first_name, :string, null: false
      add :last_name, :string, null: false
      add :age, :integer, default: 0
    end
  end
end

```

</div>
This creates column’s data types as well. We can then run the migration using


<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
  mix ecto.migrate
</div>

Schemas? Is a module that defines mappings to the underlying database table’s fields. After creating tables through migrations, we then need to tell Ecto about it through schemas. Ecto favours pluralize DB table names but the schema is often singular and therefore we need to create a Member schema for our table inside lib/family/member.ex.

<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
  ```elixir
defmodule Family.Member do
    use Ecto.Schema

    schema "members" do
      field :first_name, :string
      field :last_name, :string
      field :age, :integer, default: 0
    end
end

  ```
</div>

Family.Member module clearly tells Ecto that the schema relates to a members table with three columns; first_name, last_name and age.

Changeset? Allow developers to filter, cast, and validate changes before they apply them to the data. Inserting, updating or deleting data from the database happens through Ecto.Repo.insert/2, update/2, and deleted/2 functions. These functions take in a changeset as their first parameter. An empty changeset looks like this;





<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
  ```elixir
  Iex> %Ecto.Changeset{}
%Ecto.Changeset<action: nil, changes: %{},
 errors: [], data: nil, valid?: false>
```

</div>
At this point, the fields in our changeset are empty and may not be as useful, but the schemas that we created before provides the perfect blueprint for what the data in the fields would look like to make the changeset useful.
From the previous example we had a schema that looked like this;


  <div style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
defmodule Family.Member do
  use Ecto.Schema

  schema "members" do
    field :first_name, :string
    field :last_name, :string
    field :age, :integer, default: 0
  end
end

```
</div>

We can use this schema and the Ecto.Changeset.cast/3 function to create a changeset.
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
Iex> Ecto.Changeset.cast(%Family.Member{
  first_name: "Camila", last_name: "Mensire", age: "00"},
 %{}, [:first_name, :last_name, :age])
 %Ecto.Changeset<action: nil, changes: %{}, errors: [],
  data: %Family.Member<>, valid?: true>

```
</div>
The first parameter in the Ecto.Changeset.cast/3 function is the original data which is the initial %Family.Member{} struct in our case. Ecto is able to find the schema based on this struct. The second parameter in that order are the changes we intend to make; in this case it is just an empty map. The third and last parameter is what make the Ecto.Changeset.cast/3  special; a list of fields allowed to go through. This gives us control over what fields can be changed and safe-guard the rest.
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
Ecto.Changeset.cast(%Family.Member{first_name: "Camila",
 age: 00},
%{"first_name" => "Sara", “last_name” => “Camila”},
 [:first_name, :age])
%Ecto.Changeset<
  action: nil,
  changes: %{first_name: "Sara"},
  errors: [],
  data: %Family.Member<>,
  valid?: true
>

```
</div>
You are able to see how the first name was changed but the last name gets ignored because it was not explicitly allowed in the list of fields that got through. The Ecto.Changeset.cast/3  function has an alternative, the Ecto.Changeset.change/2  which lacks the ability to filter changes like the cast/3. The  change/2  is useful in scenarios where you are working with data manually or trust the source making the changes to your data.

With this, we can create changesets, but since we lack validation, we may end up with even unacceptable changes such as name fields with empty strings like;

<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
Iex> Ecto.Changeset.change(%Family.Member{
  first_name: "Camila", age: 00},
  %{first_name: "", age: 01})
#Ecto.Changeset<
  action: nil,
  changes: %{age: 01, first_name: ""},
  errors: [],
  data: #Family.Member<>,
  valid?: true
>

```
</div>
In the example above, Ecto says the changeset is valid, but in a real-world scenario we wouldn’t want to allow empty name, and so this needs fixing.

With Ecto comes a number of beneficial built-in validation functions. Before we look at them, let us first import Ecto.Changeset into our member.ex module with our schema since we are going to use Changeset a lot.

<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
defmodule Family.Member do
  use Ecto.Schema
  import Ecto.Changeset

  schema "members" do
   field :first_name, :string
    field :last_name, :string
    field :age, :integer, default: 0
  end
end

```
</div>
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
def changeset(struct, params) do
  struct
  |> cast(params, [:first_name,  :last_name, :age])
end

```
</div>
To make sure the first and last names are always present, we do;
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
def changeset(struct, params) do
  struct
  |> cast(params, [:first_name, :last_name, :age])
  |> validate_required([:first_name, :last_name])
end

```
</div>
With this update, and recompiling since we are on iex calling the Family.Member.changeset/2 function and passing empty first and last names make the changeset invalid. We can see this in a helpful message error in the changeset.
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
Iex> Family.Member.changeset(%Family.Member {},
%{"first_name" => "", “last_name” => “”})
%Ecto.Changeset<
  action: nil,
  changes: %{},
  errors: [
	first_name: {"can't be blank", [validation: :required]},
	last_name: {"can't be blank", [validation: :required]},

],
  data: %Family.Member<>,
  valid?: false
>

```
</div>
With the above error in the changeset, an attempt to do Repo.insert(changeset) returns a tuple of :error, changeset with the same error.

Ecto.Changeset also has the validate_length/3 function that takes some extra options;
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
def changeset(struct, params) do
  struct
  |> cast(params, [:first_name, last_name, :age])
  |> validate_required([:first_name, :last_name])
  |> validate_length(:first_name, min: 2)
   |> validate_length(:last_name, min: 2)
end

```
</div>
With this update, let’s see what the result will be if we passed first and last names that consist of single characters;
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
Iex> Family.Member.changeset(%Family.Member {},
%{"first_name" => "C", “last_name” => “S”})
%Ecto.Changeset<
  action: nil,
  changes: %{first_name: "C", last_name: “S”},
  errors: [
    last_name: {"should be at least %{count} character(s)",
     [count: 2, validation: :length,
     kind: :min, type: :string]
     },
    first_name: {"should be at least %{count} character(s)",
     [count: 2, validation: :length,
     kind: :min, type: :string]
     }
  ],
  data: % Family.Member <>,
  valid?: false
>

```
</div>
Custom Validations? This comes to play when you need something unique that the wide range of built-in changeset validators do not cover. Since every validate_ function we have seen thus far accepts and returns an Ecto.Chanegset{}, we can very well plug in our own. For example, we can make sure that only confirmed family names are allowed.
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
@fictional_names ["Rowa", "Mensire"]
def validate_family_name(changeset) do
  last_name = get_field(changeset, :last_name)

  if last_name in @family_names do
    changeset
  else
    add_error(changeset, :last_name,
    "is not a Family Member")
  end
end

```
</div>
Notice we have introduced two new helper functions; get_field/3 and add_error/4. These two have the following roles.

Since in our schema we return an %Ecto.Changeset{}, we can easily add more validations using the pipe (|>) operator.

<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
def changeset(struct, params) do
  struct
  |> cast(params, [:name, :age])
  |> validate_required([:name])
  |> validate_length(:name, min: 2)
  |> validate_fictional_name()
end


```
</div>
<div
  style={{
    backgroundColor: "grey",
    paddingTop: "30px",
    paddingLeft: "10px",
    margin: "20px",
  }}
>
```elixir
iex> Family.Member.changeset(%Family.Member{},
%{"first_name" => "Ouko", “last_name” => “Onyango”})
%Ecto.Changeset<
  action: nil,
  changes: %{first_name: "Ouko", last_name: “Onyango”},
  errors: [name: {"Is not a Family Member", []}],
  data: %Family.Member<>,
  valid?: false
>

```
</div>
Adding changes programmatically? What if we wanted to manually introduce changes to a changeset? We can utilize the put_change/3 helper function.

Instead of making the first_name field required, we could allow members without a first name, and call them “Anonymous” instead. This function, like the one we just saw above, accepts and returns a changeset.


Associations? Three types;

Belongs To/Has Many

````
